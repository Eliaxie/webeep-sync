import { app, BrowserWindow, dialog, ipcMain, protocol, } from 'electron'
import { loginManager } from './helpers/login'
import { Course, moodleClient } from './helpers/moodle'
import { initalizeStore, store } from './helpers/store'
import { downloadManager } from './helpers/download'

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) { // eslint-disable-line global-require
    app.quit()
}

const createWindow = (): void => {
    // Create the browser window.
    const mainWindow = new BrowserWindow({
        height: 600,
        width: 800,
        autoHideMenuBar: true,
        titleBarStyle: 'hidden',
        titleBarOverlay: true,
        minHeight: 400,
        minWidth: 600,
        webPreferences: {
            nodeIntegration: true,
            contextIsolation: false
        }
    })

    const wc = mainWindow.webContents

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)
    loginManager.on('token', () => wc.send('is-logged', true))
    loginManager.on('logout', () => wc.send('is-logged', false))
    moodleClient.on('username', username => wc.send('username', username))
    if (moodleClient.username) wc.send('username', moodleClient.username)

    downloadManager.on('sync', () => wc.send('syncing', true))
    downloadManager.on('stop', () => wc.send('syncing', false))
    downloadManager.on('progress', progress => wc.send('progress', progress))
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
    createWindow()
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
    app.quit()
})

app.on('activate', () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow()
    }
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

let coursesCache: Course[] = []

ipcMain.on('get-logged', e => {
    e.reply('is-logged', loginManager.isLogged)
    e.reply('username', moodleClient.username)
    e.reply('syncing', downloadManager.syncing)
})

ipcMain.on('logout', async e => {
    await loginManager.logout()
})

ipcMain.on('courses', async e => {
    try {
        let c = await moodleClient.getCourses()
        coursesCache = c
        e.reply('courses-return', c)
    } catch (err) {
        e.reply('courses-return', coursesCache)
    }
})

ipcMain.on('request-login', async e => {
    await loginManager.createLoginWindow()
})

ipcMain.on('set-should-sync', async (e, courseid: number, shouldSync: boolean) => {
    await initalizeStore()
    store.data.persistence.courses[courseid].shouldSync = shouldSync
    await store.write()
})

ipcMain.on('sync-start', e => downloadManager.sync())
ipcMain.on('sync-stop', e => downloadManager.stop())

ipcMain.on('sync-status', async e => {
    await initalizeStore()
    e.reply('download-path', store.data.settings.downloadPath)
    e.reply('autosync', store.data.settings.autosyncEnabled)
})

ipcMain.on('select-download-path', async e => {
    let path = await dialog.showOpenDialog({
        properties: ['openDirectory', 'createDirectory',],
        title: 'select download folder'
    })
    if (!path.canceled) {
        store.data.settings.downloadPath = path.filePaths[0]
        e.reply('download-path', path.filePaths[0])
        await store.write()
    }
})
ipcMain.on('set-autosync', async (e, sync: boolean) => {
    await initalizeStore()
    store.data.settings.autosyncEnabled = sync
    e.reply('autosync', sync)
    await store.write()
})

ipcMain.handle('lastsynced', e => {
    return store.data.persistence.lastSynced
})

ipcMain.handle('settings', e => {
    let settingsCopy = { ...store.data.settings }
    // this two settings are not managed in the settings menu
    delete settingsCopy.autosyncEnabled
    delete settingsCopy.downloadPath
    return settingsCopy
})
ipcMain.handle('set-settings', async (e, newSettings) => {
    store.data.settings = { ...store.data.settings, ...newSettings }
    await store.write()
})